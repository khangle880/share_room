package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"errors"
	"fmt"
	"log"
	"slices"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/khangle880/share_room/graph/dataloader"
	"github.com/khangle880/share_room/graph/model"
	"github.com/khangle880/share_room/utils"
)

// Icon is the resolver for the icon field.
func (r *budgetResolver) Icon(ctx context.Context, obj *model.Budget) (*model.Icon, error) {
	index := slices.IndexFunc(r.icons, func(e *model.Icon) bool { return e.ID == obj.IconId })
	if index == -1 {
		return nil, fmt.Errorf("not found budget's icon: %v", obj.IconId)
	}
	return r.icons[index], nil
}

// Room is the resolver for the room field.
func (r *budgetResolver) Room(ctx context.Context, obj *model.Budget) (*model.Room, error) {
	panic(fmt.Errorf("not implemented: Room - room"))
}

// Transactions is the resolver for the transactions field.
func (r *budgetResolver) Transactions(ctx context.Context, obj *model.Budget) ([]*model.Transaction, error) {
	transList := utils.Filter(r.transactions, func(trans *model.Transaction) bool {
		return trans.BudgetId == obj.ID
	})
	return transList, nil
}

// Members is the resolver for the members field.
func (r *budgetResolver) Members(ctx context.Context, obj *model.Budget) ([]*model.User, error) {
	var members []*model.User
	members, _ = dataloader.GetUserLoader(ctx).LoadAll(utils.ToStrings(obj.MemberIds))
	return members, nil
}

// Icon is the resolver for the icon field.
func (r *categoryResolver) Icon(ctx context.Context, obj *model.Category) (*model.Icon, error) {
	index := slices.IndexFunc(r.icons, func(e *model.Icon) bool { return e.ID == obj.IconId })
	if index == -1 {
		return nil, fmt.Errorf("not found category's icon: %v", obj.IconId)
	}
	return r.icons[index], nil
}

// Parent is the resolver for the parent field.
func (r *categoryResolver) Parent(ctx context.Context, obj *model.Category) (*model.Category, error) {
	if obj.ParentId == nil {
		return nil, nil
	}
	parent, err := r.CategoriesRepo.GetCategoryByID(*obj.ParentId)
	if err != nil {
		return nil, fmt.Errorf("not found category's parent: %v", *obj.ParentId)
	}
	return parent, nil
}

// Icon is the resolver for the icon field.
func (r *eventResolver) Icon(ctx context.Context, obj *model.Event) (*model.Icon, error) {
	index := slices.IndexFunc(r.icons, func(e *model.Icon) bool { return e.ID == obj.IconId })
	if index == -1 {
		return nil, fmt.Errorf("not found event's icon: %v", obj.IconId)
	}
	return r.icons[index], nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Token, error) {
	user, err := r.UsersRepo.GetUserByEmail(email)
	if err != nil {
		return nil, errors.New("user not found")
	}
	if err := utils.ComparePasswords(password, user.HashedPassword); err != nil {
		return nil, err
	}
	token, err := utils.JwtGenerate(user.ID)
	if err != nil {
		return nil, err
	}
	return &model.Token{
		AccessToken: &token,
		User:        user,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.CreateUserInput) (*model.Token, error) {
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		log.Printf("error while hashing password %v", err)
		return nil, errors.New("something went wrong")
	}
	now := time.Now().UTC()
	user := &model.User{
		ID:             uuid.New(),
		Username:       input.Username,
		HashedPassword: hashedPassword,
		Email:          input.Email,
		Phone:          input.Phone,
		Firstname:      input.Firstname,
		Lastname:       input.Lastname,
		Role:           *input.Role,
		Bio:            input.Bio,
		Avatar:         input.Avatar,
		CreatedAt:      now,
		UpdatedAt:      &now,
	}

	tx, err := r.UsersRepo.DB.Begin()
	if err != nil {
		log.Printf("error while creating transaction: %v", err)
		return nil, errors.New("something went wrong")
	}
	defer tx.Rollback()

	_, err = r.UsersRepo.CreateUser(tx, user)
	if err != nil {
		log.Printf("error while creating user, %v", err)
		if strings.Contains(err.Error(), "duplicate key") {
			return nil, fmt.Errorf("user already exists")
		}
		return nil, errors.New("someting went wrong")
	}
	if err := tx.Commit(); err != nil {
		log.Printf("error committing transaction: %v", err)
		return nil, errors.New("someting went wrong")
	}

	token, err := utils.JwtGenerate(user.ID)
	if err != nil {
		log.Printf("error while generate token: %v", err)
		return nil, errors.New("something went wrong")
	}

	return &model.Token{
		AccessToken: &token,
		User:        user,
	}, nil
}

// CreateIcon is the resolver for the createIcon field.
func (r *mutationResolver) CreateIcon(ctx context.Context, input model.CreateIconInput) (*model.Icon, error) {
	iconType := "term"
	icon := &model.Icon{
		ID:        uuid.New(),
		Name:      input.Name,
		URL:       input.URL,
		Type:      &iconType,
		CreatedAt: time.Time{},
		UpdatedAt: time.Time{},
	}
	return icon, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error) {
	event := &model.Event{
		ID:          uuid.New(),
		Name:        input.Name,
		Description: input.Description,
		IconId:      input.IconID,
		Background:  new(string),
		CreatedAt:   time.Time{},
		UpdatedAt:   time.Time{},
	}
	return event, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	now := time.Now().UTC()
	category := &model.Category{
		ID:        uuid.New(),
		Name:      input.Name,
		Type:      input.Type,
		IconId:    input.IconID,
		ParentId:  input.ParentID,
		CreatedAt: now,
		UpdatedAt: now,
	}
	_, err := r.CategoriesRepo.CreateCategory(category)
	return category, err
}

// CreateBudget is the resolver for the createBudget field.
func (r *mutationResolver) CreateBudget(ctx context.Context, input model.CreateBudgetInput) (*model.Budget, error) {
	now := time.Now()
	budget := &model.Budget{
		ID:          uuid.New(),
		Name:        input.Name,
		Description: input.Description,
		Amount:      input.Amount,
		IconId:      input.IconID,
		RoomId:      input.RoomID,
		MemberIds:   input.MemberIDs,
		CreatedAt:   now,
		UpdatedAt:   now,
	}
	_, err := r.BudgetsRepo.CreateBudget(budget)
	return budget, err
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.CreateTransInput) (*model.Transaction, error) {
	transaction := &model.Transaction{
		ID:          uuid.New(),
		CategoryId:  input.CategoryID,
		Description: input.Description,
		ExcTime:     time.Time{},
		BudgetId:    input.BudgetID,
		CreatorIds:  input.CreatorIDs,
		PartnerIds:  input.PartnerIDs,
		EventId:     input.EventID,
		Images:      []string{},
		CreatedAt:   time.Time{},
		UpdatedAt:   time.Time{},
	}
	return transaction, nil
}

// UpdateBudget is the resolver for the updateBudget field.
func (r *mutationResolver) UpdateBudget(ctx context.Context, id uuid.UUID, input model.UpdateBudgetInput) (*model.Budget, error) {
	budget, err := r.BudgetsRepo.GetBudgetByID(id)
	if err != nil || budget == nil {
		return nil, errors.New("budget not exist")
	}
	didUpdate := false
	if input.Name != nil {
		budget.Name = *input.Name
		didUpdate = true
	}
	if input.Description != nil {
		*budget.Description = *input.Description
		didUpdate = true
	}
	if input.Amount != nil {
		budget.Amount = *input.Amount
		didUpdate = true
	}
	if input.IconID != nil {
		budget.IconId = *input.IconID
		didUpdate = true
	}
	if input.MemberIDs != nil {
		budget.MemberIds = input.MemberIDs
		didUpdate = true
	}
	if !didUpdate {
		return nil, errors.New("no any changes")
	}
	now := time.Now().UTC()
	budget.UpdatedAt = now
	_, err = r.BudgetsRepo.UpdateBudget(budget)
	if err != nil {
		return nil, fmt.Errorf("error while updating budget: %v", err)
	}
	return budget, nil
}

// DeleteBudget is the resolver for the deleteBudget field.
func (r *mutationResolver) DeleteBudget(ctx context.Context, id uuid.UUID) (bool, error) {
	budget, err := r.BudgetsRepo.GetBudgetByID(id)
	if err != nil || budget == nil {
		return false, errors.New("budget not exist")
	}
	err = r.BudgetsRepo.DeleteBudget(budget)
	if err != nil {
		return false, fmt.Errorf("error while deleting budget %v", err)
	}
	return true, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, role model.UserRole) ([]*model.User, error) {
	return r.UsersRepo.GetUsers()
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, filter *model.BudgetFilter, limit *int, offset *int) ([]*model.Category, error) {
	return r.CategoriesRepo.GetCategories(filter, limit, offset)
}

// Budgets is the resolver for the budgets field.
func (r *queryResolver) Budgets(ctx context.Context) ([]*model.Budget, error) {
	return r.BudgetsRepo.GetBudgets()
}

// Admin is the resolver for the admin field.
func (r *roomResolver) Admin(ctx context.Context, obj *model.Room) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Admin - admin"))
}

// Member is the resolver for the member field.
func (r *roomResolver) Member(ctx context.Context, obj *model.Room) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Member - member"))
}

// Category is the resolver for the category field.
func (r *transactionResolver) Category(ctx context.Context, obj *model.Transaction) (*model.Category, error) {
	category, err := r.CategoriesRepo.GetCategoryByID(obj.CategoryId)
	if err != nil {
		return nil, fmt.Errorf("not found transaction's category: %d", obj.CategoryId)
	}
	return category, nil
}

// Budget is the resolver for the budget field.
func (r *transactionResolver) Budget(ctx context.Context, obj *model.Transaction) (*model.Budget, error) {
	budget, err := r.BudgetsRepo.GetBudgetByID(obj.BudgetId)
	if err != nil {
		return nil, fmt.Errorf("not found transaction's budget: %v", obj.BudgetId)
	}
	return budget, nil
}

// Event is the resolver for the event field.
func (r *transactionResolver) Event(ctx context.Context, obj *model.Transaction) (*model.Event, error) {
	if obj.EventId == nil {
		return nil, nil
	}
	index := slices.IndexFunc(r.events, func(e *model.Event) bool { return e.ID == *obj.EventId })
	if index == -1 {
		return nil, fmt.Errorf("not found transaction's event: %v", obj.EventId)
	}
	return r.events[index], nil
}

// Creators is the resolver for the creators field.
func (r *transactionResolver) Creators(ctx context.Context, obj *model.Transaction) ([]*model.User, error) {
	var creators []*model.User

	for _, creatorId := range obj.CreatorIds {
		creator, err := r.UsersRepo.GetUserByID(creatorId)
		if err != nil {
			creators = append(creators, creator)
		}
	}
	return creators, nil
}

// Partners is the resolver for the partners field.
func (r *transactionResolver) Partners(ctx context.Context, obj *model.Transaction) ([]*model.User, error) {
	var partners []*model.User

	for _, partnerId := range obj.PartnerIds {
		partner, err := r.UsersRepo.GetUserByID(partnerId)
		if err != nil {
			partners = append(partners, partner)
		}
	}
	return partners, nil
}

// LastLoginAt is the resolver for the lastLoginAt field.
func (r *userResolver) LastLoginAt(ctx context.Context, obj *model.User) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: LastLoginAt - lastLoginAt"))
}

// Budget returns BudgetResolver implementation.
func (r *Resolver) Budget() BudgetResolver { return &budgetResolver{r} }

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Room returns RoomResolver implementation.
func (r *Resolver) Room() RoomResolver { return &roomResolver{r} }

// Transaction returns TransactionResolver implementation.
func (r *Resolver) Transaction() TransactionResolver { return &transactionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type budgetResolver struct{ *Resolver }
type categoryResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type roomResolver struct{ *Resolver }
type transactionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
