package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"slices"
	"time"

	"github.com/google/uuid"
	"github.com/khangle880/share_room/graph/model"
	"github.com/khangle880/share_room/utils"
)

// Transactions is the resolver for the transactions field.
func (r *budgetResolver) Transactions(ctx context.Context, obj *model.Budget) ([]*model.Transaction, error) {
	transList := utils.Filter(r.transactions, func(trans *model.Transaction) bool {
		return trans.BudgetID == obj.ID
	})
	return transList, nil
}

// Icon is the resolver for the icon field.
func (r *budgetResolver) Icon(ctx context.Context, obj *model.Budget) (*model.Icon, error) {
	index := slices.IndexFunc(r.icons, func(e *model.Icon) bool { return e.ID == obj.IconID })
	if index == -1 {
		return nil, fmt.Errorf("not found budget's icon: %v", obj.IconID)
	}
	return r.icons[index], nil
}

// Members is the resolver for the members field.
func (r *budgetResolver) Members(ctx context.Context, obj *model.Budget) ([]*model.User, error) {
	var members []*model.User

	for _, memberId := range obj.MemberIDs {
		index := slices.IndexFunc(r.users, func(user *model.User) bool { return user.ID == memberId })
		if index != -1 {
			members = append(members, r.users[index])
		}
	}
	return members, nil
}

// Icon is the resolver for the icon field.
func (r *categoryResolver) Icon(ctx context.Context, obj *model.Category) (*model.Icon, error) {
	index := slices.IndexFunc(r.icons, func(e *model.Icon) bool { return e.ID == obj.IconID })
	if index == -1 {
		return nil, fmt.Errorf("not found category's icon: %v", obj.IconID)
	}
	return r.icons[index], nil
}

// Parent is the resolver for the parent field.
func (r *categoryResolver) Parent(ctx context.Context, obj *model.Category) (*model.Category, error) {
	if obj.ParentID == nil {
		return nil, nil
	}
	index := slices.IndexFunc(r.categories, func(e *model.Category) bool { return e.ID == *obj.ParentID })
	if index == -1 {
		return nil, fmt.Errorf("not found category's parent: %v", obj.ParentID)
	}
	return r.categories[index], nil
}

// Icon is the resolver for the icon field.
func (r *eventResolver) Icon(ctx context.Context, obj *model.Event) (*model.Icon, error) {
	index := slices.IndexFunc(r.icons, func(e *model.Icon) bool { return e.ID == obj.IconID })
	if index == -1 {
		return nil, fmt.Errorf("not found event's icon: %v", obj.IconID)
	}
	return r.icons[index], nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, err
	}
	now := time.Now().UTC()
	user := &model.User{
		ID:             uuid.New(),
		Username:       input.Username,
		HashedPassword: hashedPassword,
		Email:          input.Email,
		Phone:          input.Phone,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		Role:           *input.Role,
		Bio:            input.Bio,
		Avatar:         input.Avatar,
		CreatedAt:      now,
		UpdatedAt:      &now,
	}
	r.users = append(r.users, user)
	return user, nil
}

// CreateIcon is the resolver for the createIcon field.
func (r *mutationResolver) CreateIcon(ctx context.Context, input model.CreateIconInput) (*model.Icon, error) {
	iconType := "term"
	icon := &model.Icon{
		ID:        uuid.New(),
		Name:      input.Name,
		URL:       input.URL,
		Type:      &iconType,
		CreatedAt: time.Time{},
		UpdatedAt: &time.Time{},
	}
	return icon, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	now := time.Now().UTC()
	category := &model.Category{
		ID:        uuid.New(),
		Name:      input.Name,
		Type:      input.Type,
		IconID:    input.IconID,
		ParentID:  input.ParentID,
		CreatedAt: now,
		UpdatedAt: &now,
	}
	r.categories = append(r.categories, category)
	return category, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error) {
	event := &model.Event{
		ID:          uuid.New(),
		Name:        input.Name,
		Description: input.Description,
		IconID:      input.IconID,
		Background:  new(string),
		CreatedAt:   time.Time{},
		UpdatedAt:   &time.Time{},
	}
	return event, nil
}

// CreateBudget is the resolver for the createBudget field.
func (r *mutationResolver) CreateBudget(ctx context.Context, input model.CreateBudgetInput) (*model.Budget, error) {
	budget := &model.Budget{
		ID:             uuid.New(),
		Name:           input.Name,
		Description:    input.Description,
		Balance:        input.Balance,
		TransactionIDs: input.TransactionIDs,
		IconID:         input.IconID,
		MemberIDs:      input.MemberIDs,
		CreatedAt:      time.Time{},
		UpdatedAt:      &time.Time{},
	}
	return budget, nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.CreateTransInput) (*model.Transaction, error) {
	transaction := &model.Transaction{
		ID:          uuid.New(),
		CategoryID:  input.CategoryID,
		Description: input.Description,
		Time:        time.Time{},
		BudgetID:    input.BudgetID,
		CreatorIDs:  input.CreatorIDs,
		PartnerIDs:  input.PartnerIDs,
		EventID:     input.EventID,
		Images:      []string{},
		CreatedAt:   time.Time{},
		UpdatedAt:   &time.Time{},
	}
	return transaction, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, role model.UserRoleEnum) ([]*model.User, error) {
	return r.users, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	return r.categories, nil
}

// Category is the resolver for the category field.
func (r *transactionResolver) Category(ctx context.Context, obj *model.Transaction) (*model.Category, error) {
	index := slices.IndexFunc(r.transactions, func(e *model.Transaction) bool { return e.ID == obj.CategoryID })
	if index == -1 {
		return nil, fmt.Errorf("not found transaction's category: %d", obj.CategoryID)
	}
	return r.categories[index], nil
}

// Budget is the resolver for the budget field.
func (r *transactionResolver) Budget(ctx context.Context, obj *model.Transaction) (*model.Budget, error) {
	index := slices.IndexFunc(r.budgets, func(e *model.Budget) bool { return e.ID == obj.BudgetID })
	if index == -1 {
		return nil, fmt.Errorf("not found transaction's budget: %v", obj.BudgetID)
	}
	return r.budgets[index], nil
}

// Creators is the resolver for the creators field.
func (r *transactionResolver) Creators(ctx context.Context, obj *model.Transaction) ([]*model.User, error) {
	var creators []*model.User

	for _, creatorId := range obj.CreatorIDs {
		index := slices.IndexFunc(r.users, func(user *model.User) bool { return user.ID == creatorId })
		if index != -1 {
			creators = append(creators, r.users[index])
		}
	}
	return creators, nil
}

// Partners is the resolver for the partners field.
func (r *transactionResolver) Partners(ctx context.Context, obj *model.Transaction) ([]*model.User, error) {
	var partners []*model.User

	for _, partnerId := range obj.PartnerIDs {
		index := slices.IndexFunc(r.users, func(user *model.User) bool { return user.ID == partnerId })
		if index != -1 {
			partners = append(partners, r.users[index])
		}
	}
	return partners, nil
}

// Event is the resolver for the event field.
func (r *transactionResolver) Event(ctx context.Context, obj *model.Transaction) (*model.Event, error) {
	if obj.EventID == nil {
		return nil, nil
	}
	index := slices.IndexFunc(r.events, func(e *model.Event) bool { return e.ID == *obj.EventID })
	if index == -1 {
		return nil, fmt.Errorf("not found transaction's event: %v", obj.EventID)
	}
	return r.events[index], nil
}

// Budget returns BudgetResolver implementation.
func (r *Resolver) Budget() BudgetResolver { return &budgetResolver{r} }

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Transaction returns TransactionResolver implementation.
func (r *Resolver) Transaction() TransactionResolver { return &transactionResolver{r} }

type budgetResolver struct{ *Resolver }
type categoryResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type transactionResolver struct{ *Resolver }
