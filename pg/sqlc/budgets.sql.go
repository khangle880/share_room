// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: budgets.sql

package pg

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBudget = `-- name: CreateBudget :one
INSERT INTO budgets (name, description, amount, icon_id, room_id, period, start_date, end_date)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, name, description, amount, icon_id, room_id, period, start_date, end_date
`

type CreateBudgetParams struct {
	Name        string         `json:"name"`
	Description *string        `json:"description"`
	Amount      pgtype.Numeric `json:"amount"`
	IconID      uuid.UUID      `json:"icon_id"`
	RoomID      uuid.NullUUID  `json:"room_id"`
	Period      NullPeriodType `json:"period"`
	StartDate   time.Time      `json:"start_date"`
	EndDate     *time.Time     `json:"end_date"`
}

func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (Budget, error) {
	row := q.db.QueryRow(ctx, createBudget,
		arg.Name,
		arg.Description,
		arg.Amount,
		arg.IconID,
		arg.RoomID,
		arg.Period,
		arg.StartDate,
		arg.EndDate,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.IconID,
		&i.RoomID,
		&i.Period,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
DELETE FROM budgets WHERE id = $1
`

func (q *Queries) DeleteBudget(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBudget, id)
	return err
}

const getBudgetByID = `-- name: GetBudgetByID :one
SELECT id, created_at, updated_at, name, description, amount, icon_id, room_id, period, start_date, end_date FROM budgets WHERE id = $1
`

func (q *Queries) GetBudgetByID(ctx context.Context, id uuid.UUID) (Budget, error) {
	row := q.db.QueryRow(ctx, getBudgetByID, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.IconID,
		&i.RoomID,
		&i.Period,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getBudgets = `-- name: GetBudgets :many
SELECT id, created_at, updated_at, name, description, amount, icon_id, room_id, period, start_date, end_date FROM budgets
OFFSET $1
LIMIT $2
`

type GetBudgetsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetBudgets(ctx context.Context, arg GetBudgetsParams) ([]Budget, error) {
	rows, err := q.db.Query(ctx, getBudgets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.IconID,
			&i.RoomID,
			&i.Period,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetsByIDs = `-- name: GetBudgetsByIDs :many
SELECT id, created_at, updated_at, name, description, amount, icon_id, room_id, period, start_date, end_date FROM budgets WHERE id = ANY($1::UUID[])
`

func (q *Queries) GetBudgetsByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]Budget, error) {
	rows, err := q.db.Query(ctx, getBudgetsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Amount,
			&i.IconID,
			&i.RoomID,
			&i.Period,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersByBudgetIDs = `-- name: GetMembersByBudgetIDs :many
SELECT u.id, u.created_at, u.updated_at, u.deleted_at, u.last_join_at, u.username, u.hashed_password, u.email, u.phone, bm.budget_id
FROM users u
INNER JOIN budget_members bm ON u.id = bm.user_id
WHERE bm.budget_id = ANY($1::UUID[])
GROUP BY bm.budget_id
`

type GetMembersByBudgetIDsRow struct {
	User     User      `json:"user"`
	BudgetID uuid.UUID `json:"budget_id"`
}

func (q *Queries) GetMembersByBudgetIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]GetMembersByBudgetIDsRow, error) {
	rows, err := q.db.Query(ctx, getMembersByBudgetIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMembersByBudgetIDsRow{}
	for rows.Next() {
		var i GetMembersByBudgetIDsRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.LastJoinAt,
			&i.User.Username,
			&i.User.HashedPassword,
			&i.User.Email,
			&i.User.Phone,
			&i.BudgetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBudgetMember = `-- name: SetBudgetMember :exec
INSERT INTO budget_members (user_id, budget_id, role)
VALUES ($1, $2, $3)
`

type SetBudgetMemberParams struct {
	UserID   uuid.UUID  `json:"user_id"`
	BudgetID uuid.UUID  `json:"budget_id"`
	Role     BudgetRole `json:"role"`
}

func (q *Queries) SetBudgetMember(ctx context.Context, arg SetBudgetMemberParams) error {
	_, err := q.db.Exec(ctx, setBudgetMember, arg.UserID, arg.BudgetID, arg.Role)
	return err
}

const unsetBudgetMembers = `-- name: UnsetBudgetMembers :exec
DELETE FROM budget_members 
WHERE budget_id = $1
`

func (q *Queries) UnsetBudgetMembers(ctx context.Context, budgetID uuid.UUID) error {
	_, err := q.db.Exec(ctx, unsetBudgetMembers, budgetID)
	return err
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE budgets
SET updated_at = NOW(),
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    amount = COALESCE($4, amount),
    icon_id = COALESCE($5, icon_id),
    room_id = COALESCE($6, room_id),
    period = COALESCE($7, period),
    start_date = COALESCE($8, start_date),
    end_date = COALESCE($9, end_date)
WHERE id = $1
RETURNING id, created_at, updated_at, name, description, amount, icon_id, room_id, period, start_date, end_date
`

type UpdateBudgetParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        *string        `json:"name"`
	Description *string        `json:"description"`
	Amount      pgtype.Numeric `json:"amount"`
	IconID      uuid.NullUUID  `json:"icon_id"`
	RoomID      uuid.NullUUID  `json:"room_id"`
	Period      NullPeriodType `json:"period"`
	StartDate   *time.Time     `json:"start_date"`
	EndDate     *time.Time     `json:"end_date"`
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (Budget, error) {
	row := q.db.QueryRow(ctx, updateBudget,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Amount,
		arg.IconID,
		arg.RoomID,
		arg.Period,
		arg.StartDate,
		arg.EndDate,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Amount,
		&i.IconID,
		&i.RoomID,
		&i.Period,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}
