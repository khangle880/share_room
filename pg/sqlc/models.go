// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0

package pg

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BudgetRole string

const (
	BudgetRoleOwner       BudgetRole = "owner"
	BudgetRoleContributor BudgetRole = "contributor"
)

func (e *BudgetRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BudgetRole(s)
	case string:
		*e = BudgetRole(s)
	default:
		return fmt.Errorf("unsupported scan type for BudgetRole: %T", src)
	}
	return nil
}

type NullBudgetRole struct {
	BudgetRole BudgetRole `json:"budget_role"`
	Valid      bool       `json:"valid"` // Valid is true if BudgetRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBudgetRole) Scan(value interface{}) error {
	if value == nil {
		ns.BudgetRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BudgetRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBudgetRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BudgetRole), nil
}

type CategoryType string

const (
	CategoryTypeExpense CategoryType = "expense"
	CategoryTypeIncome  CategoryType = "income"
)

func (e *CategoryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CategoryType(s)
	case string:
		*e = CategoryType(s)
	default:
		return fmt.Errorf("unsupported scan type for CategoryType: %T", src)
	}
	return nil
}

type NullCategoryType struct {
	CategoryType CategoryType `json:"category_type"`
	Valid        bool         `json:"valid"` // Valid is true if CategoryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCategoryType) Scan(value interface{}) error {
	if value == nil {
		ns.CategoryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CategoryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCategoryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CategoryType), nil
}

type PeriodType string

const (
	PeriodTypeWeekly  PeriodType = "weekly"
	PeriodTypeMonthly PeriodType = "monthly"
	PeriodTypeYearly  PeriodType = "yearly"
)

func (e *PeriodType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PeriodType(s)
	case string:
		*e = PeriodType(s)
	default:
		return fmt.Errorf("unsupported scan type for PeriodType: %T", src)
	}
	return nil
}

type NullPeriodType struct {
	PeriodType PeriodType `json:"period_type"`
	Valid      bool       `json:"valid"` // Valid is true if PeriodType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPeriodType) Scan(value interface{}) error {
	if value == nil {
		ns.PeriodType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PeriodType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPeriodType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PeriodType), nil
}

type RoomRole string

const (
	RoomRoleAdmin  RoomRole = "admin"
	RoomRoleMember RoomRole = "member"
)

func (e *RoomRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RoomRole(s)
	case string:
		*e = RoomRole(s)
	default:
		return fmt.Errorf("unsupported scan type for RoomRole: %T", src)
	}
	return nil
}

type NullRoomRole struct {
	RoomRole RoomRole `json:"room_role"`
	Valid    bool     `json:"valid"` // Valid is true if RoomRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRoomRole) Scan(value interface{}) error {
	if value == nil {
		ns.RoomRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RoomRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRoomRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RoomRole), nil
}

type StatusType string

const (
	StatusTypePending    StatusType = "pending"
	StatusTypeInProgress StatusType = "in_progress"
	StatusTypeCompleted  StatusType = "completed"
)

func (e *StatusType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StatusType(s)
	case string:
		*e = StatusType(s)
	default:
		return fmt.Errorf("unsupported scan type for StatusType: %T", src)
	}
	return nil
}

type NullStatusType struct {
	StatusType StatusType `json:"status_type"`
	Valid      bool       `json:"valid"` // Valid is true if StatusType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStatusType) Scan(value interface{}) error {
	if value == nil {
		ns.StatusType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StatusType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStatusType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StatusType), nil
}

type TaskRole string

const (
	TaskRoleAssignee TaskRole = "assignee"
	TaskRoleReviewer TaskRole = "reviewer"
	TaskRoleCreator  TaskRole = "creator"
)

func (e *TaskRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskRole(s)
	case string:
		*e = TaskRole(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskRole: %T", src)
	}
	return nil
}

type NullTaskRole struct {
	TaskRole TaskRole `json:"task_role"`
	Valid    bool     `json:"valid"` // Valid is true if TaskRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskRole) Scan(value interface{}) error {
	if value == nil {
		ns.TaskRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskRole), nil
}

type TransRole string

const (
	TransRoleCreator TransRole = "creator"
	TransRolePartner TransRole = "partner"
)

func (e *TransRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransRole(s)
	case string:
		*e = TransRole(s)
	default:
		return fmt.Errorf("unsupported scan type for TransRole: %T", src)
	}
	return nil
}

type NullTransRole struct {
	TransRole TransRole `json:"trans_role"`
	Valid     bool      `json:"valid"` // Valid is true if TransRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransRole) Scan(value interface{}) error {
	if value == nil {
		ns.TransRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransRole), nil
}

type UserRole string

const (
	UserRoleAdmin UserRole = "admin"
	UserRoleUser  UserRole = "user"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type Account struct {
	ID             uuid.UUID  `json:"id"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`
	DeletedAt      *time.Time `json:"deleted_at"`
	LastJoinAt     time.Time  `json:"last_join_at"`
	Username       string     `json:"username"`
	HashedPassword string     `json:"hashed_password"`
	Email          *string    `json:"email"`
	Phone          *string    `json:"phone"`
}

type Budget struct {
	ID          uuid.UUID      `json:"id"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	Name        string         `json:"name"`
	Description *string        `json:"description"`
	Amount      pgtype.Numeric `json:"amount"`
	IconID      uuid.UUID      `json:"icon_id"`
	RoomID      uuid.NullUUID  `json:"room_id"`
	Period      NullPeriodType `json:"period"`
	StartDate   time.Time      `json:"start_date"`
	EndDate     *time.Time     `json:"end_date"`
}

type BudgetMember struct {
	ID       uuid.UUID  `json:"id"`
	UserID   uuid.UUID  `json:"user_id"`
	BudgetID uuid.UUID  `json:"budget_id"`
	Role     BudgetRole `json:"role"`
}

type Category struct {
	ID        uuid.UUID     `json:"id"`
	CreatedAt time.Time     `json:"created_at"`
	UpdatedAt time.Time     `json:"updated_at"`
	Name      string        `json:"name"`
	Type      CategoryType  `json:"type"`
	IconID    uuid.UUID     `json:"icon_id"`
	ParentID  uuid.NullUUID `json:"parent_id"`
}

type Event struct {
	ID          uuid.UUID `json:"id"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	IconID      uuid.UUID `json:"icon_id"`
	Background  string    `json:"background"`
}

type Icon struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	Type      *string   `json:"type"`
}

type Profile struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Role      UserRole  `json:"role"`
	Firstname *string   `json:"firstname"`
	Lastname  *string   `json:"lastname"`
	Dob       time.Time `json:"dob"`
	Bio       *string   `json:"bio"`
	Avatar    *string   `json:"avatar"`
}

type Room struct {
	ID         uuid.UUID `json:"id"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	Name       string    `json:"name"`
	Address    *string   `json:"address"`
	Avatar     *string   `json:"avatar"`
	Background *string   `json:"background"`
}

type RoomMember struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
	Role   RoomRole  `json:"role"`
}

type Transaction struct {
	ID          uuid.UUID      `json:"id"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	CategoryID  uuid.UUID      `json:"category_id"`
	BudgetID    uuid.NullUUID  `json:"budget_id"`
	EventID     uuid.NullUUID  `json:"event_id"`
	ExcTime     time.Time      `json:"exc_time"`
	Description *string        `json:"description"`
	Amount      pgtype.Numeric `json:"amount"`
	Images      []string       `json:"images"`
}

type TransactionMember struct {
	ID            uuid.UUID `json:"id"`
	UserID        uuid.UUID `json:"user_id"`
	TransactionID uuid.UUID `json:"transaction_id"`
	Role          TransRole `json:"role"`
}

type User struct {
	ID             uuid.UUID  `json:"id"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`
	DeletedAt      *time.Time `json:"deleted_at"`
	LastJoinAt     time.Time  `json:"last_join_at"`
	Username       string     `json:"username"`
	HashedPassword string     `json:"hashed_password"`
	Email          *string    `json:"email"`
	Phone          *string    `json:"phone"`
}

type UserProfile struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	ProfileID uuid.UUID `json:"profile_id"`
}
